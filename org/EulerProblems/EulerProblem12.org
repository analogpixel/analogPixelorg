* Lessons Learned
  * Python is slow, really really slow.  PyPy is a JIT compiler for python that can speed it up by a factor of a lot.  My final solution ran in 24seconds using PyPy, but just running it in python it took;  I stopped it at 10min, although the night before I ran some code before bed, waking up it was still running.  While trying to figure out how to optimize the code, I found PyPy, and without changing the code (which took all night not to finish) PyPy ran it in under a minute.
  * If you have memory, use the memory.  Don't try to append to an array over and over.  Allocate enough memory that you can just write without trying to resize.  Resizing/append might work early on , but as the array grows it doesn't.  A good hash, with plenty of memory will probably speed up any algorithm.
  * use iterators instead of ranges, ranges take up memory, iterators do not.  Or just use while loops that count instead of range(1,largeNum)  (xrange is better in python 2.7)
  * Understand the problem, and only solve that.  My original solution was collecting all the factors of each number, this was a lot of extra information that wasn't needed.  Then I would go through and count all those values.  My final solution just kept a counter of how many factors each number had, I didn't need to know what they where, just that the number had them.  I've seen inventory systems that do the same thing; instead of collecting all the information and letting you search it, it does a scan, and puts the information you care about in buckets.  When you have too much data, you can't keep it all, so only keep what you actually need to solve the problem.
  * find smarter ways to do things.  Instead of calculating all the factors by dividing each number by all possible values, I figured out a quicker way of doing it.  This goes back to fully understanding the problem.
  * Unit tests.  While this program didn't have unit tests, unit tests would have caught some dumb calculations I was making early on.  It also forces you to validate that you know your data.  does a[0] == the first number or the 0 number?  Am I calculating all the factors correctly?

* Problem
  The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

  Let us list the factors of the first seven triangle numbers:

   1: 1
   3: 1,3
   6: 1,2,3,6
  10: 1,2,5,10
  15: 1,3,5,15
  21: 1,3,7,21
  28: 1,2,4,7,14,28
  We can see that 28 is the first triangle number to have over five divisors.

  What is the value of the first triangle number to have over five hundred divisors?

** Solution
   Too slow

   #+begin_src python
   import math
   i = 0
   t = 0

   while True:
       i = i + 1
       t = t + i

       # only look for even numbers
       g = t % 10
       if g == 1 or g == 3 or g == 7 or g == 9:
           continue

       tot = 0
       a = 0
       while True:
           a = a + 1
           if a > t:
               break
           if t % a == 0:
               tot = tot + 1

       if tot > 500:
           print t
           break

   #+end_src


* Solution 2
  #+begin_src python
  import math
  import time

  # how many itterations of triangle numbers do we go for
  MAX=8000

  i=0
  t=0
  tnums = []
  while i < MAX:
      t = t + i
      tnums.append(t)
      i = i + 1

  # the last t num is the max number of factors we need to look for
  MAX = tnums[-1]

  print "Starting factors up to:", MAX

  factors = []
  for i in range(MAX +1):
      factors.append( [] )

  factors[0] = [0]
  factors[1] = [1]

  t1 = time.time()
  for i in range(1,MAX+1):
      if i*i < MAX +1:
          factors[i*i].append(i)
      for j in range(i+1, MAX+1):
          n = i * j
          if n <= MAX:
              factors[n].append(i)
              factors[n].append(j)
          else:
              break
  print("main ran in %f" % (time.time() - t1) )


  #print factors

  print "Searching for Match"
  for i in tnums:
      if len(factors[i]) > 500:
          print i, len(factors[i])
          break

  #+end_src


* Correct
  #+begin_src python
  import math
  import time
  import sys

  MAX = 80000000
  factors = [0] * (MAX+1)

  print "Looking for largest:", MAX
  t1 = time.time()

  for i in range(1, MAX+1):
      o = i * i
      if o < MAX+1:
          factors[o] += 1

      for j in range(i+1, MAX+1):
          n = i * j
          if n < MAX:
              factors[n] += 2
          else:
              break

  i=0
  t=0
  while True:
      t = t + i
      i = i + 1
      if t >= MAX:
          print "No solution:", t
          break
      if factors[t] > 500:
          print "Solution:", t
          break



  print("main ran in %f" % (time.time() - t1) )
  #+end_src


* Links
  (Integer Factorization)[http://en.wikipedia.org/wiki/Integer_factorization]

@TAGS ll,factor,factorization,
